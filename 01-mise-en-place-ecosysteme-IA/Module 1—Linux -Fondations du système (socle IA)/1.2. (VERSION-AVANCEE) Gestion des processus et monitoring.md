# Gestion des processus et monitoring

**Surveiller et contrôler vos entraînements IA**

---

## Note importante

Les corrections détaillées des exercices pratiques sont disponibles dans le **repository GitHub du cours**, indiqué dans le document d’introduction (section 0.1).

---

## Table des matières

1. [Processus : concepts de base](#processus-base)
2. [Monitoring système](#monitoring-systeme)
3. [Gestion des processus](#gestion-processus)
4. [Sessions longues et arrière-plan](#sessions-longues)
5. [Annexes — scripts et astuces](#annexes)

---

## 1. Processus : concepts de base <a id="processus-base"></a>

### Théorie : qu’est-ce qu’un processus

Un **processus** est une instance d’un programme en cours d’exécution. Un processus a :

* un **PID** (Process ID),
* un **PPID** (PID parent),
* un **état** (R, S, T, Z),
* des **ressources** (CPU, mémoire, fichiers ouverts, GPU).

En IA, on rencontre : entraînements PyTorch/TensorFlow, prétraitements ETL, notebooks Jupyter, services de monitoring.

---

### États, signaux, hiérarchie

| Concept                | Description                                            | Commandes utiles           |
| ---------------------- | ------------------------------------------------------ | -------------------------- |
| **États**              | R (running), S (sleeping I/O), T (stopped), Z (zombie) | `ps`, `top`, `htop`        |
| **Signaux**            | SIGTERM, SIGKILL, SIGSTOP, SIGCONT                     | `kill`, `trap`             |
| **Arbre de processus** | Parent → enfants (workers, data loaders)               | `pstree -p`, `ps --forest` |

#### Schéma ASCII — arbre de processus typique entraînement PyTorch

```
systemd(1)
└─sshd(1421)───bash(24308)───python(25110) train.py --config ...
                      │
                      ├─python(25125) dataloader_worker_0
                      ├─python(25126) dataloader_worker_1
                      └─python(25127) dataloader_worker_2
```

---

### Commandes essentielles (liste élargie)


| Commande                                                                      | Utilité                            | Exemple IA                        | Remarque            |
| ----------------------------------------------------------------------------- | ---------------------------------- | --------------------------------- | ------------------- |
| `ps aux`                                                                      | Lister tous les processus          | repérer `python train.py`         | vue globale         |
| `ps -eo pid,ppid,user,pcpu,pmem,etime,cmd --sort=-pcpu`                       | Vue triée par CPU                  | isoler consommateurs              | détaillé            |
| `ps --forest -o pid,ppid,cmd`                                                 | Affichage en arbre (ASCII)         | visualiser parents/enfants        | utile en debugging  |
| `pgrep -af python`                                                            | PIDs + ligne de commande           | retrouver plusieurs entraînements | rapide              |
| `pidof python`                                                                | PID d’un binaire                   | automatisation scripts            | limité à 1 binaire  |
| `lsof -p <PID>`                                                               | Fichiers ouverts par un processus  | vérifier accès logs/datasets      | diagnostic          |
| `strace -p <PID>`                                                             | Syscalls en temps réel             | déboguer blocages I/O             | très verbeux        |
| `watch -n 2 'ps -C python,python3 -o pid,pcpu,pmem,cmd --sort=-pcpu \| head'` | Refresh périodique                 | suivi léger des top processus     | pratique monitoring |
| `htop`                                                                        | Interface interactive              | filtrer sur `python`              | nécessite paquet    |
| `top -u <user>`                                                               | Vue temps réel par utilisateur     | suivre jobs de recherche IA       | standard            |
| `dstat -cdngym`                                                               | Stats CPU, disque, réseau, mémoire | détecter goulots d’étranglement   | polyvalent          |
| `iotop`                                                                       | Consommation disque par PID        | identifier dataset lourd          | nécessite droits    |
| `nvidia-smi -l 2`                                                             | Usage GPU NVIDIA (refresh 2s)      | monitoring GPU pour TensorFlow    | essentiel IA        |




**Exemple pratique : identifier un entraînement PyTorch occupant le GPU**

```bash
ps -eo pid,ppid,user,pcpu,pmem,cmd --sort=-pmem | grep -E 'python.*train|torch|tensorflow' | grep -v grep
```

---

## 2. Monitoring système <a id="monitoring-systeme"></a>

### Théorie : surveiller CPU, RAM, I/O, GPU

Objectifs : éviter **OOM**, **I/O wait** élevés, **GPU sous-utilisé**. Ajuster batch size, nombre de workers, préchargement, cache disque.

---

### CPU / RAM / Load

| Outil           | Focus                        | Commandes clés                            |
| --------------- | ---------------------------- | ----------------------------------------- |
| `top`           | Vue classique                | `top` → tri par `P` (CPU), `M` (RAM)      |
| `htop`          | Vue enrichie                 | `F6` (tri), `F3` (recherche), `F9` (kill) |
| `free -h`       | RAM + swap                   | `free -h`                                 |
| `vmstat 1`      | Processus, mémoire, I/O, CPU | `vmstat 1 10`                             |
| `sar` (sysstat) | Historique CPU/mémoire       | `sar -P ALL 1 5`                          |

**Astuce :** un `load average` > nombre de cœurs peut indiquer saturation CPU/I/O.

---

### Disque / I/O

| Outil          | Ce que ça montre             | Exemple                           |
| -------------- | ---------------------------- | --------------------------------- |
| `iotop`        | Processus top I/O            | `sudo iotop -oPa`                 |
| `iostat -xz 1` | Utilisation disque + attente | `iostat -xz 1`                    |
| `dstat`        | Mix CPU/mem/net/disk         | `dstat -cdngy --top-io --top-mem` |

**Indicateurs clés** : `%util` > 80% et `await` élevé → goulot disque (dataset lent).

---

### Réseau

| Outil     | Ce que ça montre          | Exemple              |               |
| --------- | ------------------------- | -------------------- | ------------- |
| `iftop`   | Flux réseau en temps réel | `sudo iftop -i eth0` |               |
| `nload`   | Débit simple              | `nload`              |               |
| `ss -tnp` | Connexions TCP par PID    | \`ss -tnp            | grep python\` |

---

### GPU (NVIDIA)

| Outil                     | Focus                   | Exemple                   |
| ------------------------- | ----------------------- | ------------------------- |
| `nvidia-smi`              | Utilisation GPU/mémoire | `nvidia-smi`              |
| `nvidia-smi dmon -s pucm` | Monitoring continu      | `nvidia-smi dmon -s pucm` |
| `watch -n 2 nvidia-smi`   | Rafraîchissement        | `watch -n 2 nvidia-smi`   |
| `nvtop`                   | Vue interactive         | `nvtop`                   |
| `gpustat`                 | Résumé multi-GPU        | `gpustat --watch 2`       |

**Vérifications IA à faire :**

* Utilisation GPU \~ 90–100% (sinon CPU/I/O goulot).
* Mémoire GPU stable < capacité (sinon OOM).
* Température/Power safe.

---

### Table « métriques à surveiller » (checklist)

| Ressource | Indicateur         | Cible / Interprétation              |
| --------- | ------------------ | ----------------------------------- |
| CPU       | `%us`, `%sy`, load | équilibré, éviter load >> nb cœurs  |
| RAM       | `available`, swap  | swap ≈ 0 en entraînement            |
| I/O       | `%util`, `await`   | `%util` < 80%, `await` faible       |
| GPU       | util%, mem%, temp  | util% élevé, mem% stable, temp safe |
| Réseau    | débit/latence      | stable si data distant              |

---

## 3. Gestion des processus <a id="gestion-processus"></a>

### Signaux et contrôle

| Signal         | Effet                    | Quand l’utiliser           |
| -------------- | ------------------------ | -------------------------- |
| `SIGTERM` (15) | Arrêt propre (catchable) | arrêter avec sauvegarde    |
| `SIGKILL` (9)  | Arrêt forcé              | processus bloqué           |
| `SIGSTOP`      | Pause (comme Ctrl+Z)     | libérer GPU temporairement |
| `SIGCONT`      | Reprise                  | continuer entraînement     |

**Commandes :**

```bash
# envoyer un SIGTERM propre
kill <PID>

# pause / reprise
kill -STOP <PID>
kill -CONT <PID>

# arrêt forcé
kill -9 <PID>
```

---

### Priorités CPU & I/O

| Commande                  | Description                | Exemple pratique              |
| ------------------------- | -------------------------- | ----------------------------- |
| `nice -n 10 cmd`          | Lancer avec priorité basse | `nice -n 10 python train.py`  |
| `renice -n 15 -p <PID>`   | Modifier priorité en cours | diminuer priorité concurrente |
| `ionice -c2 -n7 -p <PID>` | Baisser priorité I/O       | éviter d’étouffer le disque   |

---

### Arrière-plan, jobs, nohup

| Méthode         | À savoir                | Exemple                                 |
| --------------- | ----------------------- | --------------------------------------- |
| `&`             | lié au terminal         | `python train.py &`                     |
| `Ctrl+Z` + `bg` | job control             | suspendre puis arrière-plan             |
| `fg %1`         | ramener au 1er plan     | contrôle interactif                     |
| `nohup ... &`   | survit à la déconnexion | `nohup python train.py &`               |
| Redirection     | logs persistants        | `python train.py > logs/run.log 2>&1 &` |

---

### Diagnostics avancés

| Outil             | Utilité              | Exemple                  |
| ----------------- | -------------------- | ------------------------ |
| `lsof -p <PID>`   | descripteurs ouverts | fichiers/datasets lockés |
| `pmap <PID>`      | cartographie mémoire | fuite mémoire suspecte   |
| `gdb -p <PID>`    | debugging natif      | blocages C/CUDA          |
| `strace -p <PID>` | appels système       | attente I/O              |

---

#### Schéma ASCII — cycle de contrôle d’un entraînement

```
[START] --> run (R) --(SIGSTOP)--> paused (T) --(SIGCONT)--> run (R)
   |                                |
   +--(SIGTERM)--> graceful shutdown +--(SIGKILL)--> forced stop
```

---

## 4. Sessions longues et arrière-plan <a id="sessions-longues"></a>

### Pourquoi tmux/screen

Les entraînements doivent survivre à la déconnexion SSH. `tmux` et `screen` permettent d’attacher/détacher des sessions persistantes.

---

### tmux — commandes clés

| Action           | Commande                    |
| ---------------- | --------------------------- |
| Créer session    | `tmux new -s ia-session`    |
| Détacher         | `Ctrl-b d`                  |
| Lister           | `tmux ls`                   |
| Attacher         | `tmux attach -t ia-session` |
| Nouveau window   | `Ctrl-b c`                  |
| Split vertical   | `Ctrl-b %`                  |
| Split horizontal | `Ctrl-b "`                  |
| Naviguer panes   | `Ctrl-b ←↑→↓`               |
| Renommer window  | `Ctrl-b ,`                  |

#### Schéma ASCII — layout tmux conseillé pour IA

```
Session: ia-session
Window 1: train
┌───────────────────────────┐
│ Pane A: python train.py   │  (logs → logs/train.log)
├───────────────┬───────────┤
│ Pane B: htop  │ Pane C: watch -n2 nvidia-smi
└───────────────┴───────────┘

Window 2: dev (vim, tests)
Window 3: logs (tail -f logs/*.log)
```

**Bloc de démarrage rapide :**

```bash
tmux new -s ia-session \; \
  rename-window 'train' \; \
  split-window -h \; \
  split-window -v \; \
  select-pane -L \; \
  send-keys 'python train.py > logs/train.log 2>&1' C-m \; \
  select-pane -R \; \
  send-keys 'watch -n 2 nvidia-smi' C-m \; \
  select-pane -D \; \
  send-keys 'htop' C-m
```

---

### screen — équivalents utiles

| Action                  | Commande       |
| ----------------------- | -------------- |
| Nouvelle session nommée | `screen -S ia` |
| Détacher                | `Ctrl-a d`     |
| Lister                  | `screen -ls`   |
| Rejoindre               | `screen -r ia` |

---

### Bonnes pratiques sessions longues

* **Rediriger logs** : `> logs/run.log 2>&1`
* **Checkpoints** réguliers (sauvegarde modèle)
* **Surveillance** dans un pane (htop, nvidia-smi)
* **Nettoyage** en fin de run (fichiers temporaires)

---

## 5. Annexes — scripts et astuces <a id="annexes"></a>

### A. Scripts de charge pour tests

**CPU burner (Python)**

```bash
python - <<'PY'
import math, time
t=time.time()
while time.time()-t < 120:
    [math.sqrt(i) for i in range(200000)]
PY
```

**Alloc mémoire (attention RAM)**

```bash
python - <<'PY'
import time
x = bytearray(1024*1024*1024)  # ~1 GiB
time.sleep(60)
PY
```

**I/O lourd (fichier 2 GiB)**

```bash
dd if=/dev/zero of=bigfile.bin bs=1M count=2048 oflag=direct
```

---

### B. Script d’entraînement « robuste » (pièges + SIGTERM)

```bash
cat > train.sh <<'SH'
#!/usr/bin/env bash
set -Eeuo pipefail
LOG_DIR="logs"; mkdir -p "$LOG_DIR"
RUN_LOG="$LOG_DIR/train_$(date +%F_%H-%M-%S).log"

cleanup() { echo "[INFO] Cleanup..."; # sync; rm -f temp_* ; 
}
trap 'echo "[INFO] SIGTERM reçu, sauvegarde..."; touch checkpoint.sig; cleanup; exit 143' TERM
trap 'echo "[ERR] Erreur inattendue"; cleanup' ERR

echo "[INFO] Start at $(date)"
python train.py 2>&1 | tee -a "$RUN_LOG"
echo "[INFO] End at $(date)"
SH
chmod +x train.sh
```

**Lancement persistant :**

```bash
nohup ./train.sh > logs/runner.out 2>&1 &
```

---

### C. Alerte simple en shell (seuil GPU)

```bash
watch -n 60 "nvidia-smi --query-gpu=utilization.gpu,memory.used --format=csv,noheader | awk -F, '{gsub(/ %| MiB/,\"\"); if(\$1<50) print \"[WARN] GPU util low:\" \$1\"% mem:\" \$2\"MiB\"}'"
```

---

### D. Table « problèmes fréquents → causes probables → actions »

| Symptôme         | Causes probables                              | Actions                                                        |
| ---------------- | --------------------------------------------- | -------------------------------------------------------------- |
| GPU util faible  | DataLoader lent, I/O disque, batch trop petit | augmenter `num_workers`, `pin_memory`, précharger, SSD, batch↑ |
| OOM GPU          | Batch trop grand, fragmentation mémoire       | batch↓, gradient accumulation, `torch.cuda.empty_cache()`      |
| CPU 100%         | Trop de workers / contention                  | ajuster workers, profiler, limiter threads BLAS                |
| I/O `%util` 100% | Disque saturé                                 | passer sur NVMe/SSD, découper datasets, caching                |
| Swap en hausse   | RAM insuffisante                              | batch↓, précalculs, augmenter RAM/swap (temporaire)            |

---

### E. Schéma ASCII — pipeline de monitoring d’un run

```
[tmux session]
   ├─ Pane A: python train.py  > logs/train.log 2>&1
   ├─ Pane B: watch -n 2 nvidia-smi
   └─ Pane C: htop  (F6 tri par MEM)
                 │
                 └─ Alertes simples (watch/awk) → messages console
```

---

## Exercices pratiques (non corrigés)

**Exercice 1 : Exploration des processus**

* Affichez `ps --forest -o pid,ppid,cmd | head -30` et identifiez parents/enfants.
* Trouvez tous les `python` avec `pgrep -af python`.
* Montrez les 5 plus gros consommateurs RAM via `ps -eo pid,pmem,cmd --sort=-pmem | head`.

**Exercice 2 : Simulation entraînement**

* Exécutez les scripts CPU/I/O des Annexes.
* Surveillez via `top`, `htop`, `iotop`, `iostat -xz 1`.
* Notez les pics CPU, RAM, I/O, et expliquez les goulots.

**Exercice 3 : Monitoring complet**

* Exécutez `watch -n 2 nvidia-smi` et `free -h` en parallèle (tmux).
* Comparez `top` vs `htop` pour le même run.
* Mesurez l’impact d’un batch size différent.

**Exercice 4 : Profiling système**

* Lancez 2 jobs concurrents ; priorisez l’un via `renice`/`ionice`.
* Montrez la différence de latence disque (`iostat -xz`).
* Concluez sur l’allocation de ressources.

**Exercice 5 : Contrôle des processus**

* Lancez un process en arrière-plan (`&`).
* Suspendez (`kill -STOP`), reprenez (`kill -CONT`), arrêtez proprement (`SIGTERM`).
* Vérifiez les effets dans `ps` et `htop`.

**Exercice 6 : Gestion avancée**

* Repérez un « zombie » simulé (script enfant orphelin).
* Utilisez `pstree -p` pour analyser.
* Décrivez les étapes de nettoyage.

**Exercice 7 : Sessions persistantes**

* Créez `tmux ia-session` avec 3 panes comme le schéma.
* Lancez un run + monitoring.
* Détachez/attachez, validez la persistance des logs.

**Exercice 8 : Workflow overnight**

* Lancez `train.sh` (Annexe B) via `nohup`.
* Vérifiez les logs, créez un checkpoint sur SIGTERM.
* Documentez un protocole de reprise.

**Exercice 9 : Automatisation**

* Écrivez un mini-script bash qui alerte si `GPU util < 50%` pendant 5 minutes.
* Montrez la commande finale (watch/awk ou boucle `while`).

---

## Conclusion

### Points clés à retenir

* **Processus** : états, PIDs, et hiérarchie déterminent le contrôle.
* **Monitoring** : combinez CPU/RAM/I/O/GPU pour diagnostiquer.
* **Contrôle** : signaux, priorités, arrière-plan, logs.
* **Persistance** : `tmux`/`screen` pour survivre aux déconnexions.

### Compétences acquises

* Identifier/monitorer vos entraînements IA.
* Diagnostiquer goulots CPU/RAM/I/O/GPU.
* Maîtriser signaux, priorités et sessions persistantes.
* Automatiser logging et alertes simples.

### Prochaines étapes

Module suivant : **Variables d’environnement et configuration système** (Conda, CUDA, chemins, threads BLAS, profils `.bashrc`/`.zshrc`, ulimit).
