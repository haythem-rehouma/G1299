# Gestion des processus et monitoring

Surveiller et contrôler vos entraînements IA

## Note importante

Les corrections des exercices pratiques de ce module sont disponibles dans le repository GitHub du cours mentionné dans le document d'introduction (0.1).

## Table des matières

1. [Processus : concepts de base](#processus-base)
2. [Monitoring système](#monitoring-systeme)
3. [Gestion des processus](#gestion-processus)
4. [Sessions longues et arrière-plan](#sessions-longues)

## Processus : concepts de base

### Théorie : Qu'est-ce qu'un processus

Un processus est un programme en cours d'exécution. En IA, vous lancerez souvent des entraînements longs qui doivent tourner en arrière-plan pendant des heures ou des jours. Comprendre la gestion des processus est crucial.

### Types de processus en IA

#### Processus typiques IA

| Type | Description | Durée typique | Ressources |
|------|-------------|---------------|------------|
| **Entraînement modèle** | PyTorch/TensorFlow training | Heures/Jours | GPU + CPU intensif |
| **Préparation données** | ETL, nettoyage datasets | Minutes/Heures | I/O + RAM intensif |
| **Inférence batch** | Prédictions en lot | Minutes/Heures | GPU modéré |
| **Jupyter Notebook** | Développement interactif | Sessions longues | RAM modéré |
| **Monitoring** | Surveillance métriques | Permanent | CPU/réseau léger |

#### États des processus

| État | Description | Visible dans |
|------|-------------|--------------|
| **Running (R)** | En cours d'exécution | top, ps |
| **Sleeping (S)** | En attente I/O | top, ps |
| **Stopped (T)** | Suspendu | jobs, ps |
| **Zombie (Z)** | Terminé mais pas nettoyé | ps |

### Identifier les processus

#### Commandes de base

| Commande | Description | Usage IA |
|----------|-------------|----------|
| **ps** | Liste les processus | Voir les scripts Python actifs |
| **ps aux** | Liste détaillée tous processus | Vue complète du système |
| **pgrep** | Trouve processus par nom | Localiser entraînements spécifiques |
| **pidof** | PID d'un processus nommé | Scripts d'automatisation |

### Exemples pratiques

**Scénario : Identifier un entraînement PyTorch en cours**

Processus typique qu'on peut voir :
- Script Python utilisant PyTorch
- Consommation GPU élevée
- Utilisation mémoire importante
- Processus fils pour data loading

### Pratique non corrigée

**Exercice 1 : Exploration des processus**
- Listez tous vos processus Python actifs
- Identifiez les processus consommant le plus de CPU
- Trouvez les processus liés à votre environnement graphique

**Exercice 2 : Simulation entraînement**
- Lancez un script Python simple en boucle
- Observez son comportement dans la liste des processus
- Identifiez ses caractéristiques (PID, CPU, mémoire)

## Monitoring système

### Théorie : Surveiller les ressources système

Le monitoring est essentiel en IA pour optimiser l'utilisation des ressources coûteuses (GPU, RAM) et détecter les problèmes de performance.

### Outils de monitoring temps réel

#### top - Monitoring classique

| Information | Description | Importance IA |
|-------------|-------------|---------------|
| **Load Average** | Charge système | Détecte la saturation |
| **CPU %** | Utilisation processeur | Balance CPU/GPU |
| **MEM %** | Utilisation mémoire | Évite les OOM |
| **TIME+** | Temps CPU cumulé | Durée d'entraînement |

#### htop - Version améliorée

**Avantages pour l'IA :**
- Interface colorée plus lisible
- Tri par consommation GPU (avec extensions)
- Gestion intuitive des processus
- Vue par cœur CPU

#### Monitoring mémoire

| Commande | Information | Usage IA |
|----------|-------------|----------|
| **free -h** | Mémoire disponible | Dimensionner batch size |
| **vmstat** | Statistiques mémoire virtuelle | Détecter swapping |
| **iotop** | I/O par processus | Goulots d'étranglement data |

### Monitoring GPU spécialisé

#### nvidia-smi - Monitoring NVIDIA

**Informations clés :**
- Utilisation GPU (%)
- Mémoire GPU utilisée/totale
- Température et ventilation
- Processus utilisant le GPU
- Power draw actuel

#### Monitoring continu

**Surveillance automatique :**
- Vérification périodique des ressources
- Alertes sur seuils critiques
- Logging des métriques de performance
- Détection des processus anormaux

### Exemples pratiques

**Scénario : Optimiser un entraînement de réseau de neurones**

Métriques à surveiller :
1. **GPU utilization** : Doit être proche de 100%
2. **GPU memory** : Optimiser le batch size
3. **CPU usage** : Équilibre data loading
4. **RAM usage** : Éviter le swap
5. **I/O wait** : Détecter goulots disque

### Pratique non corrigée

**Exercice 3 : Monitoring complet**
- Surveillez votre système avec différents outils
- Identifiez les ressources les plus utilisées
- Comparez les informations entre top, htop et free

**Exercice 4 : Profiling système**
- Lancez plusieurs processus simultanément
- Observez l'impact sur les performances
- Identifiez les limites de votre système

## Gestion des processus

### Théorie : Contrôler l'exécution des processus

En IA, vous devez pouvoir démarrer, arrêter, suspendre et reprendre des entraînements selon les besoins (problèmes détectés, optimisations, priorités).

### Contrôle des processus

#### Signaux système

| Signal | Commande | Action | Usage IA |
|--------|----------|--------|----------|
| **SIGTERM** | kill PID | Arrêt propre | Stop entraînement avec sauvegarde |
| **SIGKILL** | kill -9 PID | Arrêt forcé | Processus bloqué |
| **SIGSTOP** | kill -STOP PID | Suspension | Pause temporaire |
| **SIGCONT** | kill -CONT PID | Reprise | Reprendre après pause |

#### Gestion des priorités

| Commande | Description | Usage IA |
|----------|-------------|----------|
| **nice** | Lancer avec priorité | Processus moins prioritaires |
| **renice** | Modifier priorité existante | Ajuster en cours d'exécution |
| **ionice** | Priorité I/O | Équilibrer lecture datasets |

### Processus en arrière-plan

#### Méthodes de base

| Méthode | Commande | Avantage | Inconvénient |
|---------|----------|----------|--------------|
| **&** | python train.py & | Simple | Lié au terminal |
| **nohup** | nohup python train.py & | Survit à la déconnexion | Pas de contrôle |
| **jobs** | jobs, fg, bg | Contrôle interactif | Session limitée |

### Exemples pratiques

**Scénario : Gérer plusieurs entraînements simultanés**

Situations typiques :
1. **Arrêt d'urgence** : Modèle divergent
2. **Pause temporaire** : Libérer GPU pour test
3. **Ajustement priorité** : Favoriser entraînement important
4. **Surveillance continue** : Vérifier progression

### Gestion avancée

#### Processus orphelins et zombies

**Problèmes courants en IA :**
- Scripts mal fermés laissant des processus actifs
- Processus GPU non libérés
- Fuites mémoire progressives
- Fichiers temporaires non nettoyés

#### Nettoyage système

**Bonnes pratiques :**
- Vérification régulière des processus actifs
- Nettoyage des processus zombies
- Libération explicite des ressources GPU
- Monitoring de l'utilisation mémoire

### Pratique non corrigée

**Exercice 5 : Contrôle des processus**
- Lancez un processus long en arrière-plan
- Suspendez-le puis reprenez-le
- Modifiez sa priorité
- Arrêtez-le proprement

**Exercice 6 : Gestion avancée**
- Simulez plusieurs processus concurrents
- Gérez les priorités selon l'importance
- Pratiquez l'arrêt d'urgence
- Nettoyez les processus orphelins

## Sessions longues et arrière-plan

### Théorie : Maintenir des processus à long terme

Les entraînements IA peuvent durer des jours. Il faut des outils permettant de maintenir les processus même après déconnexion SSH ou fermeture de terminal.

### screen - Multiplexeur de terminal

#### Concepts de base

| Commande | Description | Usage IA |
|----------|-------------|----------|
| **screen** | Nouvelle session | Entraînement long |
| **screen -S nom** | Session nommée | Organisation par projet |
| **Ctrl+A, D** | Détacher session | Garder en arrière-plan |
| **screen -r** | Rattacher session | Reprendre le suivi |
| **screen -list** | Liste sessions | Voir tous les entraînements |

#### Avantages pour l'IA

**Bénéfices spécifiques :**
- Entraînements surviven à la déconnexion
- Organisation par projet/modèle
- Partage de sessions entre collègues
- Logs persistants des entraînements

### tmux - Alternative moderne

#### Fonctionnalités avancées

| Feature | Description | Avantage IA |
|---------|-------------|-------------|
| **Windows** | Onglets multiples | Un par entraînement |
| **Panes** | Division écran | Monitoring + logs |
| **Sessions** | Groupes de windows | Organisation par projet |
| **Attach/Detach** | Connexion flexible | Travail distant |

#### Configuration pour l'IA

**Setup typique :**
- Window 1 : Entraînement principal
- Window 2 : Monitoring (htop, nvidia-smi)
- Window 3 : Logs et debugging
- Window 4 : Tests et validation

### Gestion des sessions

#### Workflows recommandés

**Session d'entraînement type :**
1. Créer session nommée par projet
2. Configurer l'environnement (conda activate)
3. Lancer monitoring dans un pane
4. Démarrer entraînement
5. Détacher et continuer autres tâches
6. Rattacher périodiquement pour vérifier

#### Monitoring persistant

**Surveillance continue :**
- Sessions dédiées au monitoring
- Scripts automatiques de vérification
- Alerts en cas de problème
- Logging centralisé des métriques

### Exemples pratiques

**Scénario : Entraînement overnight d'un modèle de classification**

Processus complet :
1. **Préparation** : Session tmux dédiée
2. **Monitoring** : Pane avec nvidia-smi en continu
3. **Entraînement** : Script avec logging détaillé
4. **Sauvegarde** : Checkpoints automatiques
5. **Détachement** : Continuer en arrière-plan
6. **Vérification** : Contrôles périodiques à distance

### Automatisation et scripts

#### Scripts d'entraînement robustes

**Éléments essentiels :**
- Gestion d'erreurs complète
- Sauvegarde automatique régulière
- Logging détaillé avec timestamps
- Nettoyage automatique en cas d'arrêt
- Notifications de fin d'entraînement

#### Monitoring automatisé

**Surveillance intelligente :**
- Scripts de vérification de l'état
- Alerts par email/Slack en cas de problème
- Redémarrage automatique si possible
- Backup des résultats intermédiaires

### Pratique non corrigée

**Exercice 7 : Sessions persistantes**
- Créez une session screen ou tmux
- Lancez un processus long dedans
- Détachez et rattachez la session
- Organisez plusieurs sessions par projet

**Exercice 8 : Workflow complet IA**
- Simulez un entraînement overnight complet
- Configurez monitoring et logging
- Testez la récupération après déconnexion
- Pratiquez l'organisation multi-projets

**Exercice 9 : Automatisation avancée**
- Créez des scripts d'entraînement robustes
- Implémentez monitoring automatique
- Testez la gestion d'erreurs
- Configurez notifications de fin

## Conclusion

### Points clés à retenir

- **Processus** : Comprendre les états et cycles de vie des entraînements IA
- **Monitoring** : Surveiller CPU, GPU, RAM pour optimiser les performances
- **Contrôle** : Gérer priorités et signaux pour un contrôle fin
- **Persistance** : Utiliser screen/tmux pour les entraînements longs

### Compétences acquises

Après ce module, vous devriez être capable de :
- Identifier et gérer les processus d'entraînement IA
- Monitorer efficacement l'utilisation des ressources système
- Contrôler l'exécution des processus selon les besoins
- Maintenir des sessions persistantes pour les entraînements longs

### Prochaines étapes

Le module suivant couvrira les variables d'environnement et la configuration système, essentiels pour configurer vos environnements IA.
